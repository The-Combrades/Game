<html>
    <head>
        <script src="./three.js-master/build/three.js"></script>
        <script src="./three.js-master/GLTFLoader.js"></script>
        <script>
            var canvas, renderer; //the html's canvas and webglrenderer
            var world; //object of World class
            var animating = false;
            var playing = false;
            var frameNumber = 0;
            
            //used for character animations
            var mixer;
            var clock;

            //requisites for rendering the world
            var scene;
            var camera;
            
            //for building the the tunnel of the stage
            var tunnelMat;
            var tunnel;
            var collidable_objs = []; //list of Meshes that could collide with the character
            var finish_arr = []; //store the finish line mesh

            
            var player; //player model
            var playerCube; //cube approximation of character for collision detection

            var introTxt; // text shown at the begining of the level

            //build graphical world
            function createWorld()
            {
                clock = new THREE.Clock();
                renderer.setClearColor(0); //set background to black

                scene = new THREE.Scene();

                //setup camera
                camera = new THREE.PerspectiveCamera(30, canvas.width/canvas.height, 0.1, 100 ); 
                camera.position.set(0,0,30);
                camera.rotation.set(0, 0, 0);

                var light;  // A light shining from the direction of the camera; moves with the camera.
                light = new THREE.HemisphereLight(0xffffbb, 0x080820, 1);//new THREE.DirectionalLight();
                light.position.set(0,0,1);
                camera.add(light);
                scene.add(camera);
                
                //get the tunnel 
                tunnel = getTunnel();

                //get and place player in world
                player = new THREE.Object3D();
                player.add(getPlayer());
                var scale_factor = 0.7;
                player.scale.y = (scale_factor, scale_factor, scale_factor);
                player.rotation.set(0, Math.PI, 0);

                //playerCube mesh = simple approximation for player model for collision detection
                playerCube = new THREE.Mesh
                (
                    new THREE.BoxGeometry(1,2.8,0.4,50,50,50),
                    new THREE.MeshBasicMaterial({color: 'red'})
                );
                playerCube.position.set(0,-0.3, 15);
                playerCube.scale.set(scale_factor, scale_factor, scale_factor);
                playerCube.visible = false;
                scene.add(playerCube);
                scene.add(player);
                scene.add(tunnel);
            }

            //returns the player object 3D
            function getPlayer()
            {
                
                var obj = new THREE.Object3D();
                
                var modelLoader = new THREE.GLTFLoader(); 
                //load the gltf model
                modelLoader.load
                (
                    './Models/zuck/scene.gltf',
                    function(gltf)
                    {
                        mixer = new THREE.AnimationMixer(gltf.scene); //for animations
                        mixer.timeScale = 1.2;
                        var action = mixer.clipAction(gltf.animations[0]); //get running animation
                        action.play(); 

                        obj.add(gltf.scene);
                        
                        
                    },
                    undefined,
                    function(error)
                    {
                        console.error(error);
                    }
                );    

                obj.position.set(0,-2,-15); //set further from the camera
                return obj;
            }

            //draws the red tunnel
            function getTunnel()
            {  
                var tunnelColor = "rgb(150,0,20)";
                //texture for the tunnel wall
                var texture = new THREE.TextureLoader().load("./textures/brick_roughness.jpg");
                texture.wrapS = THREE.RepeatWrapping;
                texture.wrapT = THREE.RepeatWrapping;    
                texture.repeat.set(1,10); //so texture not stretched of the entire z length

                //texture for the obstacle
                var obsTexture = new THREE.TextureLoader().load("./textures/brick_roughness.jpg");
                obsTexture.wrapS = THREE.RepeatWrapping;
                obsTexture.wrapT = THREE.RepeatWrapping;    
                obsTexture.repeat.set(0.4,0.1);


                //tunnel's material
                tunnelMat = new THREE.MeshPhongMaterial
                (
                    {
                        color: tunnelColor,
                        shininess: 10,
                        map: texture
                    }
                );

                //obstacle material
                var obs_mat = new THREE.MeshPhongMaterial
                (
                        {
                            color: tunnelColor,
                            shininess:10,
                            map: obsTexture,
                            side: THREE.DoubleSide
                        }
                );

                //base mesh for tunnel walls
                var tunnel_length = 2000; //how far the tunnel runs in the z direction
                var tunnel = new THREE.Object3D();
                    var roof = new THREE.Mesh(
                        new THREE.BoxGeometry(10,2,tunnel_length),
                        tunnelMat
                    );
                    
                    //left wall of tunnel
                    var left = roof.clone();
                    left.rotation.z=Math.PI/2;
                    left.position.set(-4,-4,0);
                    //right wall
                    var right = roof.clone();
                    right.rotation.z= 3*Math.PI/2;
                    right.position.set(4,-4,0);
                    //floor
                    var floor = roof.clone();
                    floor.rotation.z= Math.PI;
                    floor.position.set(0,-8,0);

                //add tunnel components
                tunnel.add(left);
                tunnel.add(right);
                tunnel.add(roof);
                tunnel.add(floor);

                //_______________THE LEVEL's finish Line______________________\\
                var finish_texture = new THREE.TextureLoader().load("./textures/portal0.jpg");
                finish_texture.wrapS = THREE.RepeatWrapping;
                finish_texture.wrapT = THREE.RepeatWrapping;    
                finish_texture.repeat.set(1,1); //so texture not stretched of the entire z length

                //create the geometry
                var finishln = new THREE.Mesh
                (
                    new THREE.BoxGeometry(10,6,1), //a slab facing the camera
                    new THREE.MeshPhongMaterial
                    (
                        {
                            color: tunnelColor,
                            shininess: 10,
                            map: finish_texture
                        }
                    )
                );
                finishln.position.set(0, -4, -tunnel_length/2); //place it at the end of the tunnel
                tunnel.add(finishln);
                //add the finishln to an array that will be used to check if character has reached the finish line
                finish_arr.push(finishln);
                finish_arr.push(finishln); //add twice because the raycaster method takes in an array of size >2
    
                 //____________________________obstacles in the tunnel____________________\\   
                //base mesh for tunnel's obstacles
                var obstacle_mesh = new THREE.Mesh
                (
                    new THREE.BoxGeometry(10,4,3),
                    obs_mat
                );

                //add the obstacles to the floor and roof
                for(var i = 0; i < tunnel_length/2; ++i) // place obstacles within tunnel on both sides of z=0
                {
                        if(i%100 == 0) //floor every
                        {
                            var obs0 = obstacle_mesh.clone();
                            var obs1 = obstacle_mesh.clone();
                            obs0.position.set(0, -6, i + Math.random() * 30); //place obstacle a 160 paces away from last in positive z dir
                            obs1.position.set(0, -6, -i - Math.random() *30); //place in -z dir
                            tunnel.add(obs0);
                            tunnel.add(obs1);
                            //add the meshes to the list of collidable objects
                            collidable_objs.push(obs0);
                            collidable_objs.push(obs1);
    
                        }else if(i%160 == 0) //roof
                        {
                            var obs0 = obstacle_mesh.clone();
                            var obs1 = obstacle_mesh.clone();
                            obs0.position.set(0, -2, i + Math.random() * 20); //place obstacle a 160 paces away from last in positive z dir
                            obs1.position.set(0, -2, -i - Math.random() * 20); //place in -z dir
                            tunnel.add(obs0);
                            tunnel.add(obs1);
                            //add the meshes to the list of collidable objects
                            collidable_objs.push(obs0);
                            collidable_objs.push(obs1);

                        }
                }

                //add the finish to the last row of collidable_objs
                //collidable_objs.push(finishln);

                //place the tunnel further into negative z direction but still let camera start in tunnel.
                tunnel.position.set(0,5, -tunnel_length/2 + 30);  
                
                return tunnel;
            }

            
            function doRender()
            {
                renderer.render(scene, camera);
            }

            //player movements when keyboard is pressed
            doKey = function(event)
            {
                var code = event.keyCode;
                switch(code)
                {
                    //w pressed. Make roof ground
                    case 87:			
                        if(player.position.y != 2) //supposed to stop double w-rotation but the if statement not workin
                     	{
                            player.rotateZ(Math.PI);
                            player.position.set(0,2,0);
                            playerCube.position.y = 2.3;
                            //camera.position.y = 2;
                            
                         }
                         break;
                    
                    //s pressed
                    case 83: 
                        if(player.position.y != 0)
                        {
                            player.position.set(0,0,0);
                            player.rotateZ(Math.PI);
                            playerCube.position.y = -0.3;
                            //camera.position.y = 0;
                            
                        }   
                        break;
                    //space pressed
                    case 32:  
                        if(!playing) //if game isnt already playing
                        {
                            playLvl();
                        }

                    //________________control camera height___________//
                    case 38: //up
                        if(camera.position.y < 2)
                        {
                            camera.position.y += 0.1;
                        }    
                        break;

                    case 40: //down
                        if(camera.position.y > -1.5)
                        {
                            camera.position.y -= 0.1;
                        }    
                        break;

                    case 37: //left
                        if(camera.position.x > -2)
                        {
                            camera.position.x -= 0.1;
                        }    
                        break;        

                    case 39: //right
                        if(camera.position.x < 2)
                        {
                            camera.position.x += 0.1;
                        }    
                        break;        
                              

                }

                 doRender();
            }

            //called once each frame for animations
            function updateForFrame()
            {
                checkCollision();
                
                //simulate player running by moving tunnle torwads camerea
                tunnel.position.z += 0.8;
            }

            //uses raycasting to check for collsions of playerCube with obstacles
            function checkCollision()
            {
                var originPoint = playerCube.position.clone(); //get the playerCube's center

                //a ray is drawn from center to vertex i and reports interceptions(collisons)
                for(var i = 0;i < playerCube.geometry.vertices.length; ++i)
                {
                    var localV = playerCube.geometry.vertices[i].clone();
                    var globalV = localV.applyMatrix4(playerCube.matrix);
                    var dirV = globalV.sub(playerCube.position);

                    var ray = new THREE.Raycaster(originPoint, dirV.clone().normalize());

                    //first check for collision with finish line(ie if level finished)
                    var finished = ray.intersectObjects(finish_arr); 
                    if(finished.length > 0 && finished[0].distance < dirV.length())
                    {
                        document.getElementById("playCheckbox").checked = false;
                        document.location.reload();
                        alert("You have completed the first level!");
                        break;
                    }  


                    //checks collisions with the obstacles if not finished
                    var collision_results = ray.intersectObjects(collidable_objs);
                    if(collision_results.length > 0 && collision_results[0].distance < dirV.length())
                    {
                        document.getElementById("playCheckbox").checked = false;
                        document.location.reload();
                        alert("You just ran into a wall.....");
                        break;
                    }
                }
            }
        

            //when user toggles Play checkbox
            function doPlayCheckbox()
            {
                var run = document.getElementById("playCheckbox").checked;
                if(run != animating)
                {
                    animating = run;
                    if(animating)
                    {
                        requestAnimationFrame(doFrame);
                    }
                }
            }

            //called by system to drive the animation
            function doFrame()
            {
                
                if(animating)
                {
                    frameNumber++;
                    updateForFrame();

                    var delta = clock.getDelta();
                    if(mixer)mixer.update(delta);

                    doRender();
                    requestAnimationFrame(doFrame);

                }


            }

            //called when user presses space
            function playLvl()
            {
                playing = true;
                document.getElementById("playCheckbox").checked = true;
                doPlayCheckbox(); //start animating
            }
            //create text and add to scene.
            // function addIntro()
            // {
            //     var loader = new THREE.FontLoader();

            //     loader.load
            //     (
            //         './fonts/helvetiker_regular.typeface.json',
            //         function(font)
            //         {
            //             var textGeo = new THREE.TextGeometry
            //             ( 
            //                 "My Text", 
            //                 {

            //                     font: font,

            //                     size: 2,
            //                     height: 2,
            //                     curveSegments: 12,

            //                     bevelThickness: 2,
            //                     bevelSize: 5,
            //                     bevelEnabled: true

            //                 } 
            //             );

            //             var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );

            //             var mesh = new THREE.Mesh( textGeo, textMaterial );
            //             mesh.position.set(0,0,0);
            //             mesh.rotation.set(0,-Math.PI/2,0);

            //             scene.add( mesh );
            //         }
            //     );
            // }
         
            //Initialising the canvas and its children when page loads
            function init()
            {
                canvas = document.getElementById("canvas");
                //intro();
                try
                {
                    renderer = new THREE.WebGLRenderer(
                        {
                            canvas: canvas,
                            antialias: true
                        }
                    );
                }catch(e)
                {
                    alert("Your browser does not have webgl");
                }               
                document.getElementById("playCheckbox").checked = false;
                document.getElementById("playCheckbox").onchange = doPlayCheckbox;
                document.addEventListener("keydown",doKey,false);
                createWorld(); //build world
                doRender(); 
                alert("Welcome to the first level! Your goal is to get to and through the portal at the end of the tunnel. Use W to run on the roof and S to go back to the floor.To beging double tap the button space then run Mark, run! ")
            }
        </script>
    </head>

    <body onload="init()">
        <p>
            <label>
           
     <input type="checkbox" id="playCheckbox"> <b>PLAY</b>
            </label>
        </p>

        <div id="canvas-holder">
            <canvas id="canvas" width=1200 height=600></canvas>
        </div>
    </body>
</html>