<html>

<head>
    <script src="./three.js-master/build/three.js"></script>
    <script src="./three.js-master/GLTFLoader.js"></script>
    <script src="./cannon.js-master/build/cannon.js"></script>
    <script src="./cannon.js-master/tools/threejs/CannonDebugRenderer.js"></script>
    <script>
        var canvas, renderer; //the html's canvas and webglrenderer
        var world; //object of World class
        var animating = false;
        var playing = false;
        var frameNumber = 0;

        //used for character animations
        var mixer;
        var clock;

        //requisites for rendering the world
        var scene;
        var camera;
        //var light; //a point light that moves with the camera

        //for building the the tunnel of the stage
        var tunnelMat;
        var tunnel;
        var collidable_objs = []; //list of Meshes that could collide with the character
        var collidable_phys = []; //physics of collidable objects


        var player; //player model
        var playerCube; //cube approximation of character for collision detection
        var playerPhys; //player physics

        var introTxt; // text shown at the begining of the level

        var world; //physics world

        var cannonDebugRenderer;
	//simullates physics for just obstacle meshes and the player mesh.
        function worldPhysics() {
            world = new CANNON.World(); //initilise CANNON world
            world.gravity.set(0, 0, 0); 

            //Broadphase algorithm to check collisions
            world.broadphase = new CANNON.NaiveBroadphase();

            world.solver.iterations = 10;

            getTunnelPhysics();
            getPlayerPhysics();
        }

        var x0 = 0, y0 = -4.3, z0 = 950; //the initial coordinate of the player
        var lastZ = z0; //last player z coord
        var portalZ; //portal's z coord

        //build graphical world
        function createWorld() {
            clock = new THREE.Clock();
            renderer.setClearColor(0); //set background to black

            scene = new THREE.Scene();

            //setup camera
            camera = new THREE.PerspectiveCamera(30, canvas.width / canvas.height, 0.1, 100);
            camera.position.set(0, -6, 30);
            camera.rotation.set(0, 0, 0);

            var light;  // A light shining from the direction of the camera; moves with the camera.
            light = new THREE.HemisphereLight(0xffffbb, 0.1, 1);//new THREE.DirectionalLight();
            light.position.set(0, 0, 1);
            camera.add(light);
            scene.add(camera);

            //get the tunnel 
            tunnel = getTunnel();

            //get and place player in world
            player = new THREE.Object3D();
            player.add(getPlayer());
            player.position.set(x0, y0, z0);
            var scale_factor = 0.9;
            player.scale.y = (scale_factor, scale_factor, scale_factor);
            player.rotation.set(0, Math.PI, 0);

            scene.add(player);
            scene.add(tunnel);
        }



        //returns the player object 3D
        function getPlayer() {

            var obj = new THREE.Object3D();

            var modelLoader = new THREE.GLTFLoader();
            //load the gltf model
            modelLoader.load
                (
                    './Models/zuck/scene.gltf',
                    function (gltf) {
                        mixer = new THREE.AnimationMixer(gltf.scene); //for animations
                        mixer.timeScale = 1.2;
                        var action = mixer.clipAction(gltf.animations[0]); //get running animation
                        action.play();

                        obj.add(gltf.scene);


                    },
                    undefined,
                    function (error) {
                        console.error(error);
                    }
                );

            obj.position.set(0, -2, 0); //it works okay.
            return obj;
        }
	
	//approximates player physics with a cube
        function getPlayerPhysics() {
            var shape = new CANNON.Box(new CANNON.Vec3(0.5, 1.5, 0.2)); 
            playerPhys = new CANNON.Body
                (
                    {
                        mass: 1,
                        shape: shape
                    }
                );
            playerPhys.position.set(x0, y0, z0);
            playerPhys.velocity.set(0, 0, -40); //move the player now not the camera anymore
            world.addBody(playerPhys);
        }

        var obstacle_len = 10; //size in x dir
        var obstacle_height = 4; //size in y dir
        var obstacle_breadth = 3 //size in z dir

        //build physical version of tunnel
        function getTunnelPhysics() {
            //shape of a t
            for (var i = 0; i < collidable_objs.length; ++i)//for each obstacle
            {
                //create a shape half the dimensions(coz cannon and threejs appear to be related in that way) of the graphical versions
                var shape = new CANNON.Box(new CANNON.Vec3(obstacle_len / 2, obstacle_height / 2, obstacle_breadth / 2));
                var body = new CANNON.Body
                    (
                        {
                            mass: 0, //make em static
                            shape: shape
                        }
                    );
                body.position.copy(collidable_objs[i].position);
                body.velocity.set(0, 0, 0);
                world.addBody(body);
                collidable_phys.push(body); //add to the aray of the obstacle bodies
            }
        }

        //draws tunnel graphics
        function getTunnel() {
            var tunnel_length = 2000; //how far the tunnel runs in the z direction
            var tunnel_width = 10; //length in x direction
            var tunnel_breadth = 2; //length in y direction

            var tunnelColor = "rgb(150,150,150)"; //color of the tunnel
            //texture for the tunnel wall
            var texture = new THREE.TextureLoader().load("./textures/brick_roughness.jpg");
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(1, 10); //so texture not stretched of the entire z length

            //texture for the obstacle
            var obsTexture = new THREE.TextureLoader().load("./textures/brick_roughness.jpg");
            obsTexture.wrapS = THREE.RepeatWrapping;
            obsTexture.wrapT = THREE.RepeatWrapping;
            obsTexture.repeat.set(0.4, 0.1);


            //tunnel's material
            tunnelMat = new THREE.MeshPhongMaterial
                (
                    {
                        color: tunnelColor,
                        shininess: 10,
                        map: texture
                    }
                );

            //obstacle material
            var obs_mat = new THREE.MeshPhongMaterial
                (
                    {
                        color: tunnelColor,
                        shininess: 10,
                        map: obsTexture,
                        side: THREE.DoubleSide
                    }
                );

            //base mesh for tunnel walls
            var tunnel = new THREE.Object3D();
            var roof = new THREE.Mesh(
                new THREE.BoxGeometry(tunnel_width, tunnel_breadth, tunnel_length),
                tunnelMat
            );

            //left wall of tunnel
            var left = roof.clone();
            left.rotation.z = Math.PI / 2;
            left.position.set(-4, -4, 0);
            //right wall
            var right = roof.clone();
            right.rotation.z = 3 * Math.PI / 2;
            right.position.set(4, -4, 0);
            //floor
            var floor = roof.clone();
            floor.rotation.z = Math.PI;
            floor.position.set(0, -8, 0);

            //add tunnel components
            tunnel.add(left);
            tunnel.add(right);
            tunnel.add(roof);
            tunnel.add(floor);

            //_______________THE LEVEL's finish Line wich is a portal player goes through(checkCollision detirmines this)______________________\\
            var portal_texture = new THREE.TextureLoader().load("./textures/portal0.jpg");
            portal_texture.wrapS = THREE.RepeatWrapping;
            portal_texture.wrapT = THREE.RepeatWrapping;
            portal_texture.repeat.set(1, 1); //so texture not stretched of the entire z length

            //create the geometry
            var portal = new THREE.Mesh
                (
                    new THREE.BoxGeometry(10, 6, 1), //a slab facing the camera
                    new THREE.MeshPhongMaterial
                        (
                            {
                                color: tunnelColor,
                                shininess: 10,
                                map: portal_texture
                            }
                        )
                );
            portal.position.set(0, -4, -tunnel_length / 2); //place it at the end of the tunnel
            portalZ = portal.position.z;
            tunnel.add(portal);

            //add a light a the portal
            var portalLight = new THREE.PointLight(0xff0000, 1, 100); //white light
            portalLight.position.set(0, -4, -tunnel_length / 2 + 10);
            scene.add(portalLight);

            //____________________________obstacles in the tunnel____________________\\   
            //base mesh for tunnel's obstacles
            var obstacle_mesh = new THREE.Mesh
                (
                    new THREE.BoxGeometry(obstacle_len, obstacle_height, obstacle_breadth),
                    obs_mat
                );

            //add the obstacles to the floor and roof
            for (var i = 0; i < tunnel_length / 2; ++i) // place obstacles within tunnel on both sides of z=0
            {
                if (i % 160 == 0) //floor every
                {
                    var obs0 = obstacle_mesh.clone();
                    var obs1 = obstacle_mesh.clone();
                    obs0.position.set(0, -6, i + Math.random() * 1); //place obstacle a 160 paces away from last in positive z dir
                    obs1.position.set(0, -6, -i - Math.random() * 1); //place in -z dir
                    tunnel.add(obs0);
                    tunnel.add(obs1);
                    collidable_objs.push(obs0);
                    collidable_objs.push(obs1);


                } else if (i % 100 == 0) //roof
                {
                    var obs0 = obstacle_mesh.clone();
                    var obs1 = obstacle_mesh.clone();
                    obs0.position.set(0, -2, i + Math.random() * 1); //place obstacle a 160 paces away from last in positive z dir
                    obs1.position.set(0, -2, -i - Math.random() * 1); //place in -z dir
                    tunnel.add(obs0);
                    tunnel.add(obs1);
                    collidable_objs.push(obs0);
                    collidable_objs.push(obs1);
                }
            }
            //add point lights every hundred z positions in both directions
            for (var i = 0; i < tunnel_length / 2; i += 100) {
                //positive z direction
                var light0;  // A light shining from the top of the roof;
                light0 = new THREE.HemisphereLight(0x111111, 0.0001, 1);//a low intensity gray color
                light0.position.set(0, 0, i);
                scene.add(light0);

                //-z direction
                var light1;  // A light shining from the top of the roof;
                light1 = new THREE.HemisphereLight(0x111111, 0.0001, 1);//a low intensity gray color
                light1.position.set(0, 0, -i);
                scene.add(light1);
            }
            return tunnel;
        }


        function doRender() {

            renderer.render(scene, camera);
        }

        //player movements when keyboard is pressed
        doKey = function (event) {
            var code = event.keyCode;
            switch (code) {
                //w pressed. Make roof ground
                case 87:
                    if (playerCube.position.y != -2) //supposed to stop double w-rotation but the if statement not workin
                    {
                        player.rotateZ(Math.PI);
                        playerPhys.position.y = -2.5;
                        player.position.y = playerPhys.position.y;
                        //camera.position.y = 2;

                    }
                    break;

                //s pressed
                case 83:
                    if (playerCube.position.y != -6) {
                        player.rotateZ(Math.PI);
                        playerPhys.position.y = -5.5;
                        player.position.y = playerPhys.position.y;
                        //camera.position.y = 0;

                    }
                    break;
                //space pressed
                case 32:
                    if (!playing) //if game isnt already playing
                    {
                        playLvl();
                    }
                    break;

                //________________control camera height___________//
                case 38: //up
                    if (camera.position.y < -2) {
                        camera.position.y += 0.1;
                    }
                    break;

                case 40: //down
                    if (camera.position.y > -6) {
                        camera.position.y -= 0.1;
                    }
                    break;

                case 37: //left
                    if (camera.position.x > -2) {
                        camera.position.x -= 0.1;
                    }
                    break;


                    break;

                case 39: //right
                    if (camera.position.x < 2) {
                        camera.position.x += 0.1;
                    }
                    break;


            }

            doRender();
        }

        //called once each frame for animations
        function updateForFrame() {
            checkCollision();
            camera.position.z = playerPhys.position.z + 20; //keep the camera alwalys behind the player
        }
        //update positions in physics world
        function updatePhysics() {
            world.step(1 / 60);
            //increment each obstacles's body
            for (var i = 0; i < collidable_objs.length; ++i) {
                collidable_objs[i].position.copy(collidable_phys[i].position);
            }

            //playerCube.position.copy(playerPhys.position);
            player.position.copy(playerPhys.position);
        }

        //uses raycasting to check for collsions of playerCube with obstacles
        function checkCollision() {
            //checks collisions or if gone through portal
            if (playerPhys.position.z > lastZ) //if playe is going in opposite direction he has collided
            {

                document.getElementById("playCheckbox").checked = false;
                document.location.reload();
                alert("You just ran into a wall.....");

            } else if (playerPhys.position.z < portalZ) //through portal?
            {
                document.getElementById("playCheckbox").checked = false;
                document.location.reload();
                alert("You Passed the Stage!");
            } else {
                lastZ = playerPhys.position.z;
            }



        }


        //when user toggles Play checkbox
        function doPlayCheckbox() {
            var run = document.getElementById("playCheckbox").checked;
            if (run != animating) {
                animating = run;
                if (animating) {
                    requestAnimationFrame(doFrame);
                }
            }
        }

        //called by system to drive the animation
        function doFrame() {

            if (animating) {
                frameNumber++;
                updateForFrame();
                updatePhysics();

                var delta = clock.getDelta();
                if (mixer) mixer.update(delta);
                //cannonDebugRenderer.update();
                doRender();
                requestAnimationFrame(doFrame);

            }


        }

        //called when user presses space
        function playLvl() {
            playing = true;
            document.getElementById("playCheckbox").checked = true;
            doPlayCheckbox(); //start animating
        }
        //create text and add to scene.
        // function addIntro()
        // {
        //     var loader = new THREE.FontLoader();

        //     loader.load
        //     (
        //         './fonts/helvetiker_regular.typeface.json',
        //         function(font)
        //         {
        //             var textGeo = new THREE.TextGeometry
        //             ( 
        //                 "My Text", 
        //                 {

        //                     font: font,

        //                     size: 2,
        //                     height: 2,
        //                     curveSegments: 12,

        //                     bevelThickness: 2,
        //                     bevelSize: 5,
        //                     bevelEnabled: true

        //                 } 
        //             );

        //             var textMaterial = new THREE.MeshPhongMaterial( { color: 0xff0000 } );

        //             var mesh = new THREE.Mesh( textGeo, textMaterial );
        //             mesh.position.set(0,0,0);
        //             mesh.rotation.set(0,-Math.PI/2,0);

        //             scene.add( mesh );
        //         }
        //     );
        // }

        //Initialising the canvas and its children when page loads
        function init() {
            canvas = document.getElementById("canvas");
            //intro();
            try {
                renderer = new THREE.WebGLRenderer(
                    {
                        canvas: canvas,
                        antialias: true
                    }
                );
            } catch (e) {
                alert("Your browser does not have webgl");
            }
            document.getElementById("playCheckbox").checked = false;
            document.getElementById("playCheckbox").onchange = doPlayCheckbox;
            document.addEventListener("keydown", doKey, false);
            createWorld(); //build world
            worldPhysics();
            //cannonDebugRenderer = new THREE.CannonDebugRenderer(scene, world);
            doRender();
            alert("Welcome to the first level! Your goal is to get to and through the portal at the end of the tunnel. Use W to run on the roof and S to go back to the floor.To beging double tap the button space then run Mark, run! ")
        }
    </script>
</head>

<body onload="init()">
    <p>
        <label>

            <input type="checkbox" id="playCheckbox"> <b>PLAY</b>
        </label>
    </p>

    <div id="canvas-holder">
        <canvas id="canvas" width=600 height=600></canvas>
    </div>
</body>

</html>
